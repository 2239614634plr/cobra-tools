import logging
import xml.etree.ElementTree as ET

import numpy as np
from numpy.core.multiarray import ndarray

from generated.array import Array
from generated.base_enum import BaseEnum
from generated.context import ContextReference

# these attributes present on the MemStruct will not be stored on the XML
SKIPS = ("_context", "arg", "name", "io_start", "io_size", "template")
DTYPE = "dtype"
XML_STR = "xml_string"


def indent(e, level=0):
	i = "\n" + level * "	"
	if len(e):
		if not e.text or not e.text.strip():
			e.text = i + "	"
		if not e.tail or not e.tail.strip():
			e.tail = i
		for e in e:
			indent(e, level + 1)
		if not e.tail or not e.tail.strip():
			e.tail = i
	else:
		if level and (not e.tail or not e.tail.strip()):
			e.tail = i


def str_to_bool(s):
	if s.lower() == 'true':
		return True
	elif s.lower() == 'false':
		return False
	else:
		raise ValueError


class StructBase:

	context = ContextReference()

	def __init__(self, context, arg=0, template=None, set_default=True):
		self.name = ''
		self._context = context
		self.arg = arg
		self.template = template
		self.io_size = 0
		self.io_start = 0

	def get_fields_str(self, indent=0):
		return ""

	@classmethod
	def from_xml_file(cls, file_path, context, arg=0, template=None):
		"""Load Struct represented by the xml in 'file_path'"""
		instance = cls(context, arg, template, set_default=False)
		tree = ET.parse(file_path)
		xml = tree.getroot()
		instance.from_xml(xml)
		return instance

	def from_xml(self, elem):
		"""Sets the data from the XML to this MemStruct"""
		# go over all fields of this MemStruct
		# cast to tuple to avoid 'dictionary changed size during iteration'
		vars_dict = vars(self)
		# special case - handle dtype first to set defaults on struct before setting any other data
		if DTYPE in vars_dict:
			self._from_xml(self, elem, DTYPE, vars_dict[DTYPE])
			logging.debug(f"Set defaults on {self.__class__.__name__}")
			self.set_defaults()
		# special cases - these are not added to the xml definition, but need to be converted
		for prop in ("name", "game"):
			if prop in elem.attrib:
				setattr(self, prop, elem.attrib[prop])
		for prop, val in tuple(vars_dict.items()):
			# skip dummy properties
			if prop in SKIPS:
				continue
			if isinstance(val, (StructBase, Array, ndarray)):
				sub = elem.find(f'.//{prop}')
				if sub is None:
					logging.warning(f"Missing sub-element '{prop}' on XML element '{elem.tag}'")
					return
				self._from_xml(self, sub, prop, val)
			else:
				self._from_xml(self, elem, prop, val)
		# also add any meta-data that is not directly part of the struct generated by the codegen
		for attr, value in elem.attrib.items():
			if attr not in vars(self).keys():
				logging.debug(f"Adding string metadata '{attr} = {value}' from XML element '{elem.tag}'")
				setattr(self, attr, value)

	@staticmethod
	def _handle_xml_str(prop):
		return "data" if prop != XML_STR else XML_STR

	def _from_xml(self, target, elem, prop, val):
		"""Populates this MemStruct from the xml elem"""
		# print("_from_xml", elem, prop, val)
		if isinstance(val, Array):
			# create array elements
			# print(f"array {prop}, len {len(elem)}")
			val[:] = [val.dtype(self._context, 0, val.template, set_default=False) for i in range(len(elem))]
			# subelement with subelements
			for subelem, member in zip(elem, val):
				self._from_xml(self, subelem, subelem.tag, member)
		elif isinstance(val, ndarray):
			# create ndarray from data, assign value
			arr = np.fromstring(elem.text, dtype=val.dtype, sep=' ')
			setattr(target, prop, arr)
			logging.debug(f"ndarray {arr}, {val.dtype}, {type(arr)}")
		elif isinstance(val, StructBase):
			# print("MemStruct")
			val.from_xml(elem)
		elif isinstance(val, BaseEnum):
			# print("BaseEnum")
			setattr(target, prop, val.from_str(elem.attrib[prop]))
		else:
			# print("basic")
			# set basic attribute
			cls = type(val)
			if prop == XML_STR:
				# logging.debug(f"Can't handle {XML_STR} inside '{elem.tag}'")
				data = ET.tostring(elem[0], encoding="unicode").replace("\t", "").replace("\n", "")
				# override for setattr
				prop = "data"
			# strings stored as element text for readability
			elif prop == "data" and prop not in elem.attrib:
				data = elem.text
			# basic attributes
			elif prop in elem.attrib:
				data = elem.attrib[prop]
			else:
				logging.warning(f"Missing attribute '{prop}' in element '{elem.tag}'")
				return
			if data and data != "None":
				try:
					logging.debug(f"Setting {type(target).__name__}.{prop} = {data}")
					# special case as bool("False") returns true
					if cls == bool:
						setattr(target, prop, str_to_bool(data))
					else:
						setattr(target, prop, cls(data))
				except TypeError:
					raise TypeError(f"Could not convert attribute {prop} = '{data}' to {cls.__name__}")
			# if there's actually no data, don't want to create a pointer later, so set to None
			else:
				setattr(target, prop, None)

	def to_xml_file(self, file_path, debug=False):
		"""Create an xml elem representing this MemStruct, recursively set its data, indent and save to 'file_path'"""
		xml = ET.Element(self.__class__.__name__)
		self.to_xml(xml, debug)
		indent(xml)
		with open(file_path, 'wb') as outfile:
			outfile.write(ET.tostring(xml))

	def _to_xml(self, elem, prop, val, debug):
		"""Assigns data val to xml elem"""
		# logging.debug(f"_to_xml {elem.tag} - {prop}")
		if isinstance(val, Array):
			for member in val:
				cls_name = member.__class__.__name__.lower()
				member_elem = ET.SubElement(elem, cls_name)
				self._to_xml(member_elem, cls_name, member, debug)
		elif isinstance(val, ndarray):
			# elem.attrib[prop] = " ".join([str(member) for member in val])
			elem.text = " ".join([str(member) for member in val])
		elif isinstance(val, StructBase):
			val.to_xml(elem, debug)
		# basic attribute
		else:
			if prop == XML_STR:
				if val is not None:
					elem.append(ET.fromstring(val))
				else:
					logging.warning(f"bug, val should not be None for XML_STR")
			# for better readability, set ztsr pointer data as xml text
			elif prop == "data":
				if val:
					elem.text = str(val)
			# actual basic attributes
			else:
				elem.set(prop, str(val))

	def to_xml(self, elem, debug):
		"""Adds data of this MemStruct to 'elem', recursively"""
		# go over all fields of this MemStruct
		for prop, val in vars(self).items():
			if prop == "name" and val:
				elem.attrib[prop] = val
			# skip dummy properties
			if prop in SKIPS:
				continue
			# add a sub-element if these are child of a MemStruct
			if isinstance(val, (StructBase, Array, ndarray)):
				sub = ET.SubElement(elem, prop)
				self._to_xml(sub, prop, val, debug)
			else:
				self._to_xml(elem, prop, val, debug)


	@classmethod
	def read_fields(cls, stream, instance):
		pass

	@classmethod
	def write_fields(cls, stream, instance):
		pass

	@classmethod
	def _get_filtered_attribute_list(cls, instance):
		pass

	@classmethod
	def from_stream(cls, stream, context, arg=0, template=None):
		instance = cls(context, arg, template, set_default=False)
		instance.io_start = stream.tell()
		cls.read_fields(stream, instance)
		instance.io_size = stream.tell() - instance.io_start
		return instance

	@classmethod
	def to_stream(cls, stream, instance):
		instance.io_start = stream.tell()
		cls.write_fields(stream, instance)
		instance.io_size = stream.tell() - instance.io_start
		return instance